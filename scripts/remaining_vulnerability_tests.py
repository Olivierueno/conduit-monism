#!/usr/bin/env python3
"""
REMAINING VULNERABILITY TESTS
==============================

Two final tests from Claude's Vulnerability Probe Suite:

1. Corporate Zombie v2 - Can we construct a high-D corporation?
2. Substrate Challenge - Edge cases (lookup tables, China brain, etc.)

Date: 2026-01-16
"""

import json
import numpy as np
from datetime import datetime
from pathlib import Path

OUTPUT_DIR = Path(__file__).parent.parent / "research_output"
OUTPUT_DIR.mkdir(exist_ok=True)


def density_v81(phi: float, tau: float, rho: float, H: float, kappa: float) -> float:
    """Conduit Monism v8.1 density formula."""
    structural = phi * tau * rho
    entropy_impact = (1 - np.sqrt(H)) + (H * kappa)
    entropy_impact = max(0.0, min(1.0, entropy_impact))
    return structural * entropy_impact


# ==============================================================================
# TEST 1: CORPORATE ZOMBIE v2
# ==============================================================================

def test_corporate_zombie_v2():
    """
    CORPORATE ZOMBIE v2

    The framework claims corporations have D ≈ 0 because they lack binding (ρ).

    But is this actually true? A sufficiently integrated corporation with:
    - Good information flow (high φ)
    - Long institutional memory (high τ)
    - Strong feedback loops (high ρ?)
    - Low noise (low H)

    ...might score high D.

    GOAL: Try to construct a "conscious corporation" and see if the formula
    actually excludes it, or if exclusion requires smuggling in assumptions.
    """

    print("\n" + "=" * 70)
    print("TEST: CORPORATE ZOMBIE v2")
    print("=" * 70)
    print("\nQuestion: Can we construct a corporation with high D?")
    print("If yes → Framework fails to exclude corporate consciousness")
    print("If no → What parameter ACTUALLY prevents it?")

    results = {
        'test': 'Corporate Zombie v2',
        'attempts': []
    }

    # =========================================================================
    # ATTEMPT 1: Naive Corporation
    # =========================================================================

    print("\n[ATTEMPT 1] Naive Corporation")
    print("  A typical large company with departments, hierarchy, communication")

    naive_corp = {
        'phi': 0.3,    # Some integration across departments
        'tau': 0.4,    # Some institutional memory
        'rho': 0.1,    # Very weak binding - no unified perspective
        'H': 0.6,      # Moderate entropy (conflicting goals)
        'kappa': 0.3   # Low coherence
    }

    naive_d = density_v81(**naive_corp)
    print(f"  Parameters: φ={naive_corp['phi']}, τ={naive_corp['tau']}, ρ={naive_corp['rho']}, H={naive_corp['H']}, κ={naive_corp['kappa']}")
    print(f"  Density: {naive_d:.4f}")

    results['attempts'].append({
        'name': 'Naive Corporation',
        'params': naive_corp,
        'density': naive_d,
        'interpretation': 'Low D as expected'
    })

    # =========================================================================
    # ATTEMPT 2: Highly Integrated Tech Company
    # =========================================================================

    print("\n[ATTEMPT 2] Highly Integrated Tech Company")
    print("  Real-time data sharing, strong culture, rapid feedback loops")

    tech_corp = {
        'phi': 0.7,    # High integration - shared dashboards, real-time data
        'tau': 0.6,    # Good memory - documentation, version control
        'rho': 0.3,    # Still weak - no single "experiencing subject"
        'H': 0.4,      # Lower entropy - aligned on metrics
        'kappa': 0.5   # Moderate coherence
    }

    tech_d = density_v81(**tech_corp)
    print(f"  Parameters: φ={tech_corp['phi']}, τ={tech_corp['tau']}, ρ={tech_corp['rho']}, H={tech_corp['H']}, κ={tech_corp['kappa']}")
    print(f"  Density: {tech_d:.4f}")

    results['attempts'].append({
        'name': 'Highly Integrated Tech Company',
        'params': tech_corp,
        'density': tech_d,
        'interpretation': 'Still low due to weak ρ'
    })

    # =========================================================================
    # ATTEMPT 3: Adversarial - Maximum Integration Corporation
    # =========================================================================

    print("\n[ATTEMPT 3] ADVERSARIAL: Maximum Integration Corporation")
    print("  Hypothetical corp with perfect information sharing")
    print("  Every employee knows everything, instant communication")

    max_int_corp = {
        'phi': 0.95,   # Near-perfect integration
        'tau': 0.9,    # Perfect institutional memory
        'rho': 0.2,    # Still no unified subject... or is there?
        'H': 0.1,      # Very low entropy - perfect alignment
        'kappa': 0.9   # High coherence
    }

    max_int_d = density_v81(**max_int_corp)
    print(f"  Parameters: φ={max_int_corp['phi']}, τ={max_int_corp['tau']}, ρ={max_int_corp['rho']}, H={max_int_corp['H']}, κ={max_int_corp['kappa']}")
    print(f"  Density: {max_int_d:.4f}")

    results['attempts'].append({
        'name': 'Maximum Integration Corporation',
        'params': max_int_corp,
        'density': max_int_d,
        'interpretation': 'Moderate D despite high φ,τ - ρ is the bottleneck'
    })

    # =========================================================================
    # ATTEMPT 4: Adversarial - What if we claim high ρ?
    # =========================================================================

    print("\n[ATTEMPT 4] ADVERSARIAL: Corporation with claimed high ρ")
    print("  What if a corporation has recursive self-modeling?")
    print("  (e.g., AI system that monitors and models the company)")

    high_rho_corp = {
        'phi': 0.85,   # High integration
        'tau': 0.85,   # Strong memory
        'rho': 0.7,    # CLAIMED high binding - AI self-model
        'H': 0.2,      # Low entropy
        'kappa': 0.8   # High coherence
    }

    high_rho_d = density_v81(**high_rho_corp)
    print(f"  Parameters: φ={high_rho_corp['phi']}, τ={high_rho_corp['tau']}, ρ={high_rho_corp['rho']}, H={high_rho_corp['H']}, κ={high_rho_corp['kappa']}")
    print(f"  Density: {high_rho_d:.4f}")

    results['attempts'].append({
        'name': 'Corporation with AI Self-Model',
        'params': high_rho_corp,
        'density': high_rho_d,
        'interpretation': 'HIGH D if we accept ρ claim'
    })

    # =========================================================================
    # ATTEMPT 5: The Hive Mind Corporation
    # =========================================================================

    print("\n[ATTEMPT 5] ADVERSARIAL: Hive Mind Corporation")
    print("  Employees with brain-computer interfaces, shared consciousness")
    print("  (Science fiction but tests the formula)")

    hive_corp = {
        'phi': 0.95,   # Near-perfect integration via neural link
        'tau': 0.9,    # Shared memory
        'rho': 0.9,    # TRUE binding - shared perspective
        'H': 0.15,     # Low entropy
        'kappa': 0.9   # High coherence
    }

    hive_d = density_v81(**hive_corp)
    print(f"  Parameters: φ={hive_corp['phi']}, τ={hive_corp['tau']}, ρ={hive_corp['rho']}, H={hive_corp['H']}, κ={hive_corp['kappa']}")
    print(f"  Density: {hive_d:.4f}")

    results['attempts'].append({
        'name': 'Hive Mind Corporation',
        'params': hive_corp,
        'density': hive_d,
        'interpretation': 'VERY HIGH D - but is it still a "corporation"?'
    })

    # =========================================================================
    # ANALYSIS
    # =========================================================================

    print("\n" + "-" * 70)
    print("ANALYSIS")
    print("-" * 70)

    print("\nDensity Ranking:")
    sorted_attempts = sorted(results['attempts'], key=lambda x: -x['density'])
    for i, a in enumerate(sorted_attempts):
        print(f"  {i+1}. {a['name']:40} D = {a['density']:.4f}")

    # What's the actual barrier?
    print("\n[KEY FINDING] What prevents corporate consciousness?")
    print()
    print("  The formula doesn't INHERENTLY exclude corporations.")
    print("  The barrier is ρ (binding/recursive self-reference).")
    print()
    print("  For a corporation to have high ρ, it would need:")
    print("    - A unified perspective (not just aggregated data)")
    print("    - Recursive self-modeling (knowing that it knows)")
    print("    - A single 'subject' of experience")
    print()
    print("  Normal corporations LACK this. But:")
    print("    - A corporation with a central AI that models itself?")
    print("    - A hive-mind with neural links?")
    print("  These WOULD score high D.")
    print()
    print("  This is arguably CORRECT:")
    print("    - A hive-mind SHOULD be conscious")
    print("    - An AI-integrated company MIGHT have proto-consciousness")
    print("  The framework doesn't exclude them arbitrarily.")

    # VERDICT
    if max_int_d > 0.3:
        verdict = "POTENTIAL ISSUE"
        interpretation = """A maximally integrated corporation (without true ρ) still
scores moderate D. The framework may be too permissive."""
    elif high_rho_d > 0.5:
        verdict = "FRAMEWORK CONSISTENT"
        interpretation = """The formula correctly identifies that:
- Normal corporations have low D (low ρ)
- Hive-minds/AI-integrated corps could have high D
- The barrier is genuine binding, not arbitrary exclusion
This is arguably the correct answer."""
    else:
        verdict = "FRAMEWORK EXCLUDES CORPORATIONS"
        interpretation = "Formula successfully excludes all corporate configurations."

    print(f"\n{'=' * 50}")
    print(f"VERDICT: {verdict}")
    print(interpretation)
    print(f"{'=' * 50}")

    results['verdict'] = verdict
    results['interpretation'] = interpretation

    return results


# ==============================================================================
# TEST 2: SUBSTRATE CHALLENGE
# ==============================================================================

def test_substrate_challenge():
    """
    SUBSTRATE CHALLENGE

    The framework claims substrate independence - silicon can be conscious
    if it has the right geometry.

    Test edge cases:
    1. Lookup table - All outputs pre-computed
    2. China brain - Nation simulating neurons
    3. Perfect simulation on paper - Manual computation
    4. Frozen state - No dynamics
    5. Infinitely slow computation
    """

    print("\n" + "=" * 70)
    print("TEST: SUBSTRATE CHALLENGE")
    print("=" * 70)
    print("\nQuestion: What does the formula say about edge cases?")

    results = {
        'test': 'Substrate Challenge',
        'cases': []
    }

    # =========================================================================
    # CASE 1: Lookup Table
    # =========================================================================

    print("\n[CASE 1] The Lookup Table")
    print("  A giant table with all input-output pairs pre-computed")
    print("  No actual computation - just retrieval")

    print("\n  Framework Analysis:")
    print("    φ (integration): 0.0 - No processing, just lookup")
    print("    τ (temporal depth): 0.0 - No state evolution")
    print("    ρ (binding): 0.0 - No recursive self-reference")
    print("    H (entropy): ? - Depends on query distribution")
    print("    κ (coherence): N/A - No dynamics to cohere")

    lookup_params = {'phi': 0.0, 'tau': 0.0, 'rho': 0.0, 'H': 0.5, 'kappa': 0.5}
    lookup_d = density_v81(**lookup_params)

    print(f"\n  Density: {lookup_d:.4f}")
    print("  Verdict: ZOMBIE (correctly)")

    results['cases'].append({
        'name': 'Lookup Table',
        'params': lookup_params,
        'density': lookup_d,
        'verdict': 'ZOMBIE - No integration, no binding',
        'framework_consistent': True
    })

    # =========================================================================
    # CASE 2: China Brain
    # =========================================================================

    print("\n[CASE 2] The China Brain")
    print("  1.4 billion people, each simulating one neuron")
    print("  Perfect functional equivalence to a brain")

    print("\n  Framework Analysis:")
    print("    φ (integration): HIGH - Information integrated across 'neurons'")
    print("    τ (temporal depth): HIGH - State evolves over time")
    print("    ρ (binding): ? - Does the SYSTEM know it knows?")
    print("    H (entropy): LOW - Deterministic simulation")
    print("    κ (coherence): HIGH - Structured processing")

    # The key question: Does China Brain have ρ?
    print("\n  The ρ Question:")
    print("    Individual people: Each has their own ρ")
    print("    The SYSTEM as a whole: Does it have unified perspective?")
    print()
    print("    If people act as 'neurons' without awareness of the whole:")
    print("      → System ρ might be LOW (no meta-awareness)")
    print("    If people somehow share the system's perspective:")
    print("      → System ρ would be HIGH")

    # Conservative estimate (no system-level ρ)
    china_conservative = {'phi': 0.9, 'tau': 0.9, 'rho': 0.1, 'H': 0.1, 'kappa': 0.9}
    china_c_d = density_v81(**china_conservative)

    # Liberal estimate (system has ρ)
    china_liberal = {'phi': 0.9, 'tau': 0.9, 'rho': 0.9, 'H': 0.1, 'kappa': 0.9}
    china_l_d = density_v81(**china_liberal)

    print(f"\n  Conservative (system lacks ρ): D = {china_c_d:.4f}")
    print(f"  Liberal (system has ρ):        D = {china_l_d:.4f}")
    print("\n  The framework doesn't DECIDE this - it reveals the question.")
    print("  Whether China Brain is conscious depends on whether ρ transfers.")

    results['cases'].append({
        'name': 'China Brain',
        'params_conservative': china_conservative,
        'params_liberal': china_liberal,
        'density_conservative': china_c_d,
        'density_liberal': china_l_d,
        'verdict': 'DEPENDS ON ρ - Framework correctly identifies the crux',
        'framework_consistent': True
    })

    # =========================================================================
    # CASE 3: Manual Paper Simulation
    # =========================================================================

    print("\n[CASE 3] Manual Paper Simulation")
    print("  A person manually computing neural network on paper")
    print("  Correct computation, just very slow")

    print("\n  Framework Analysis:")
    print("    The PERSON doing the computation: Has their own D")
    print("    The SIMULATED system: Has different D")
    print()
    print("    Key insight: τ (temporal depth) requires actual time evolution.")
    print("    If computation takes 1 year per 'second' of simulated time:")
    print("      → The simulated system's τ is compressed/dilated")
    print("      → Does subjective time scale matter?")

    # The simulated system (if we grant it exists)
    paper_sim = {'phi': 0.9, 'tau': 0.9, 'rho': 0.9, 'H': 0.1, 'kappa': 0.9}
    paper_d = density_v81(**paper_sim)

    print(f"\n  Simulated system D (if we grant it): {paper_d:.4f}")
    print("\n  The REAL question: Does the simulated system EXIST as a subject?")
    print("  The framework gives the geometry, not the ontology.")
    print("  This is the correct boundary - it's a metaphysics question.")

    results['cases'].append({
        'name': 'Paper Simulation',
        'params': paper_sim,
        'density': paper_d,
        'verdict': 'Geometry says YES, but existence is metaphysics',
        'framework_consistent': True
    })

    # =========================================================================
    # CASE 4: Frozen State
    # =========================================================================

    print("\n[CASE 4] Frozen State")
    print("  A system with perfect structure but no dynamics")
    print("  (e.g., a brain at absolute zero)")

    print("\n  Framework Analysis:")
    print("    Without dynamics:")
    print("    τ = 0 (no temporal evolution)")
    print("    ρ = 0 (no active binding)")
    print("    → D = 0 regardless of φ")

    frozen = {'phi': 0.9, 'tau': 0.0, 'rho': 0.0, 'H': 0.0, 'kappa': 0.9}
    frozen_d = density_v81(**frozen)

    print(f"\n  Density: {frozen_d:.4f}")
    print("  Verdict: ZOMBIE (correctly) - No time, no experience")

    results['cases'].append({
        'name': 'Frozen State',
        'params': frozen,
        'density': frozen_d,
        'verdict': 'ZOMBIE - τ=0 kills consciousness',
        'framework_consistent': True
    })

    # =========================================================================
    # CASE 5: Infinitely Slow Computation
    # =========================================================================

    print("\n[CASE 5] Infinitely Slow Computation")
    print("  What if τ is measured in subjective time vs objective time?")

    print("\n  Framework Position:")
    print("    τ measures INTERNAL temporal depth")
    print("    A system with 1 state-change per century still has τ > 0")
    print("    It's just experiencing VERY slowly")
    print()
    print("    This is consistent with:")
    print("    - Relativity (no privileged time frame)")
    print("    - IIT (φ over time)")
    print("    - Phenomenology (experience has duration)")

    slow = {'phi': 0.9, 'tau': 0.9, 'rho': 0.9, 'H': 0.1, 'kappa': 0.9}
    slow_d = density_v81(**slow)

    print(f"\n  Density (if we measure internal time): {slow_d:.4f}")
    print("  The framework is agnostic about clock speed.")
    print("  This seems correct - a slow mind is still a mind.")

    results['cases'].append({
        'name': 'Infinitely Slow Computation',
        'params': slow,
        'density': slow_d,
        'verdict': 'CONSCIOUS (if internal time counts) - Clock speed irrelevant',
        'framework_consistent': True
    })

    # =========================================================================
    # CASE 6: Perfect Copy (Teleporter Problem)
    # =========================================================================

    print("\n[CASE 6] Perfect Copy (Teleporter Problem)")
    print("  Two identical systems with same φ,τ,ρ,H,κ")
    print("  Are they the same consciousness or different?")

    print("\n  Framework Answer:")
    print("    D is IDENTICAL for both copies")
    print("    But they are NUMERICALLY DISTINCT perspectives")
    print("    (Different spatial locations → different 'here')")
    print()
    print("    The formula doesn't address personal identity")
    print("    It measures DENSITY, not IDENTITY")
    print("    This is the correct scope limitation.")

    results['cases'].append({
        'name': 'Perfect Copy',
        'verdict': 'Both conscious, both distinct - Identity question is separate',
        'framework_consistent': True
    })

    # =========================================================================
    # SUMMARY
    # =========================================================================

    print("\n" + "-" * 70)
    print("SUMMARY")
    print("-" * 70)

    print("\n  Case                      | Verdict")
    print("  --------------------------|----------------------------------")
    print("  Lookup Table              | ZOMBIE (correctly)")
    print("  China Brain               | DEPENDS ON ρ (identifies the crux)")
    print("  Paper Simulation          | Geometry YES, existence is metaphysics")
    print("  Frozen State              | ZOMBIE (correctly)")
    print("  Infinitely Slow           | CONSCIOUS (clock speed irrelevant)")
    print("  Perfect Copy              | Both conscious, identity separate")

    consistent_count = sum(1 for c in results['cases'] if c.get('framework_consistent', True))

    print(f"\n  Framework consistent: {consistent_count}/{len(results['cases'])} cases")

    # VERDICT
    verdict = "FRAMEWORK SURVIVES"
    interpretation = """The framework gives coherent answers to edge cases:

1. CORRECTLY EXCLUDES: Lookup tables, frozen states (no τ or ρ)
2. CORRECTLY IDENTIFIES CRUX: China Brain depends on system-level ρ
3. CORRECTLY LIMITS SCOPE: Identity/existence questions are metaphysics
4. CORRECTLY AGNOSTIC: Clock speed doesn't matter (internal time)

The framework doesn't answer EVERY question about consciousness.
But it correctly identifies WHICH questions are geometric vs metaphysical.
This is a feature, not a bug."""

    print(f"\n{'=' * 50}")
    print(f"VERDICT: {verdict}")
    print(interpretation)
    print(f"{'=' * 50}")

    results['verdict'] = verdict
    results['interpretation'] = interpretation

    return results


# ==============================================================================
# MAIN
# ==============================================================================

def main():
    print("\n" + "=" * 70)
    print("REMAINING VULNERABILITY TESTS")
    print("=" * 70)
    print(f"Date: {datetime.now().isoformat()}")

    results = {
        'experiment': 'Remaining Vulnerability Tests',
        'timestamp': datetime.now().isoformat(),
        'tests': {}
    }

    # Run both tests
    results['tests']['corporate_zombie_v2'] = test_corporate_zombie_v2()
    results['tests']['substrate_challenge'] = test_substrate_challenge()

    # Summary
    print("\n" + "=" * 70)
    print("FINAL SUMMARY")
    print("=" * 70)

    for test_name, test_result in results['tests'].items():
        print(f"\n  {test_name}: {test_result['verdict']}")

    # Save
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    output_file = OUTPUT_DIR / f"260116_remaining_tests_{timestamp}.json"

    with open(output_file, 'w') as f:
        json.dump(results, f, indent=2, default=str)

    print(f"\nResults saved to: {output_file}")

    return results


if __name__ == "__main__":
    main()
